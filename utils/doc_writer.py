import re
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from docx.oxml import OxmlElement


def set_cell_border(cell, **kwargs):
    """
    Helper to set table cell borders in python-docx.
    """
    tc = cell._tc
    tcPr = tc.get_or_add_tcPr()
    for edge in ('top', 'left', 'bottom', 'right', 'insideH', 'insideV'):
        edge_data = kwargs.get(edge)
        if edge_data:
            tag = 'w:{}'.format(edge)
            element = tcPr.find(qn(tag))
            if element is None:
                element = OxmlElement(tag)
                tcPr.append(element)
            for key in ["val", "sz", "space", "color"]:
                if key in edge_data:
                    element.set(qn('w:{}'.format(key)), str(edge_data[key]))


def apply_markdown_formatting(paragraph, text):
    """
    Parses a string for **bold** and applies formatting to runs.
    """
    # Split by bold markers
    parts = re.split(r'(\*\*.*?\*\*)', text)
    for part in parts:
        if part.startswith('**') and part.endswith('**'):
            run = paragraph.add_run(part[2:-2])
            run.bold = True
        else:
            paragraph.add_run(part)


def save_to_docx(content, filename):
    doc = Document()

    # --- HEADER & FOOTER ---
    section = doc.sections[0]
    header = section.header
    header_para = header.paragraphs[0]
    header_para.text = "DXC Technology Limited - Confidential"
    header_para.alignment = WD_ALIGN_PARAGRAPH.RIGHT
    header_run = header_para.runs[0]
    header_run.font.size = Pt(9)
    header_run.font.color.rgb = RGBColor(100, 100, 100)

    footer = section.footer
    footer_para = footer.paragraphs[0]
    footer_para.text = "Generated by DevMate AI"
    footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
    footer_run = footer_para.runs[0]
    footer_run.font.size = Pt(8)

    # --- CONTENT PARSING ---
    lines = content.split('\n')
    table_buffer = []

    for line in lines:
        line = line.strip()
        if not line:
            continue

        # 1. Detect Tables (Lines starting and ending with |)
        if line.startswith('|') and line.endswith('|'):
            table_buffer.append(line)
            continue
        else:
            # If we were buffering a table, write it now
            if table_buffer:
                _create_table(doc, table_buffer)
                table_buffer = []

        # 2. Detect Headers
        if line.startswith('### '):
            p = doc.add_heading(line[4:], level=3)
        elif line.startswith('## '):
            p = doc.add_heading(line[3:], level=2)
        elif line.startswith('# '):
            p = doc.add_heading(line[2:], level=1)

        # 3. Detect Bullet Points
        elif line.startswith('* ') or line.startswith('- '):
            p = doc.add_paragraph(style='List Bullet')
            apply_markdown_formatting(p, line[2:])

        # 4. Normal Text
        else:
            p = doc.add_paragraph()
            apply_markdown_formatting(p, line)

    # Flush remaining table if exists
    if table_buffer:
        _create_table(doc, table_buffer)

    doc.save(filename)
    return filename


def _create_table(doc, lines):
    """Parses markdown table lines and creates a Word table."""
    # Filter out separator lines (e.g., |---|---|)
    data_lines = [l for l in lines if not set(l) <= {'|', '-', ' ', ':'}]

    if not data_lines: return

    # Determine columns
    headers = [c.strip() for c in data_lines[0].strip('|').split('|')]
    cols = len(headers)

    table = doc.add_table(rows=1, cols=cols)
    table.style = 'Table Grid'

    # Write Header
    hdr_cells = table.rows[0].cells
    for i, text in enumerate(headers):
        if i < len(hdr_cells):
            hdr_cells[i].text = text
            # Make header bold
            for paragraph in hdr_cells[i].paragraphs:
                for run in paragraph.runs:
                    run.bold = True

    # Write Data
    for line in data_lines[1:]:
        row_cells = table.add_row().cells
        cells = [c.strip() for c in line.strip('|').split('|')]
        for i, text in enumerate(cells):
            if i < len(row_cells):
                row_cells[i].text = text